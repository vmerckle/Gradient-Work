\section{Math introduction}

\subsection{Gradient Flow}

Given a smooth function $a \rightarrow F(a)$, the gradient flow is gradient descent algorithm

$a^{l+1} = a^l - \gamma \nabla F(a^l)$

with a small enough $\gamma$. If $F$ is not smooth, the gradient flow is the proximal-point algorithm

$a^{l+1} = \prox^{||\cdot ||}_{\gamma F}(a^{(l)} = \argmin_a \frac{1}{2} \norm{ a - a^{(l)}}^2 + \gamma F(a)$

with a small enough $\gamma$.

If $F$ is defined on histograms, it makes sense to use the wasserstein distance $W^p$




%Discretize mean-field limit using JKO, see if it is similar to GD.

\section{Gradient Flow vs Wasserstein GF}

Take a two layer ReLU network with $m$ neurons. Each neuron has a trainable parameter $w_i \in \R^d$ and and a fixed output sign $\alpha_i \in \{-1, 1\}$. Each of the $n$ data points of dimension $d-1$ are augmented with a $1$, so each sample is of dimension $n$. Each sample $x_j$ is stored as a row $X \in \R^{n \times d}$  and is associated with a scalar label $y_j \in \R$.

The output of one neuron is: $x \in \R^d \rightarrow \max(0, \inp{w_i}{x}) \alpha_i$, shorthand $\inp{w_i}{x}_+ ~ \alpha_i$.

The output of a network of $m$ neurons on one data point is $f(x) = \sum_{i=1}^{m} \max(0, \inp{w_i}{x}) ~ \alpha_i$

We store the neuron trainable parameter $w_i$ as the columns of $W \in \R^{d \times m}$. The loss for $n$ data points

\begin{equation}
	F(W) = \frac{1}{n} \sum_{j=1}^{n} \left(f(x_j) - y_j\right)^2
\end{equation}

Discretized, unregularized gradient descent with $\lambda \in \R^+$ stepsize: (resolving the non differentiable points $\max(0, 0)$ with 0 as gradient)

\begin{equation}
	W^{t+1} = W^t - \lambda \nabla F(W^t)
\end{equation}

Taking $\lambda \rightarrow 0$, we get the gradient flow.

Explicit discret gradient:

\begin{equation}
	\frac{\partial F}{\partial \vw^t_i} = \frac{\alpha^t_i}{n} \sum_{j=1}^{n} e^t_j ~ s^t_{i, j} ~ \vx_j
\end{equation}

With real $e^t_j = f(W^t) - y_j$ the "signed error on input $j$"

With boolean $s^t_{i, j} = \mathds{1}_{\inp{\vw^t_i}{\vx_j} > 0}$ the "is neuron $i$ activating on datapoint $j$. The vector $\vs^t_{i} \in \{0, 1\}^n$ would be the activation pattern of neuron $i$ at time $t$.

Remark: the gradient of a neuron is a linear combination of the data points it activates.

Discretized wasserstein prox step:

\begin{equation}
	W^{t+1} = \argmin_{W \in \R^{d \times m}} F(W) + \frac{1}{2 \step} W_p(W; W^t))
\end{equation}


EMD(POT library), d=squareeuclidian

\begin{align}
	W_2^2(W; W^t) &= \min_{\gamma} \inp{\gamma}{M}_F \\
	\text{s.t.  } \gamma ~ \mathbf{1} &= W \\
	\gamma^\top ~ \mathbf{1} &= W^t \\
	\gamma &\geq 0 \\
	M_{i, j} &= \lVert w_i - w_j \rVert^2_2
\end{align}

\section{3 points example}

\begin{itemize}
	\item Data: slope : $a = 2$
	\item Data: $\begin{pmatrix} X_1\\X_2\\X_3\end{pmatrix} = \begin{pmatrix}x_1 & 1 \\ x_2 & 1\\x_3 & 1 \end{pmatrix}=\begin{pmatrix} 1 \\ 2 \\ 4 \end{pmatrix}  $, $Y = \begin{pmatrix}y_1\\y_2\\y_3 \end{pmatrix} = \begin{pmatrix}a x_1^1 \\ a x_2^1 \\ a x_3^1 \end{pmatrix} $
	\item Loss: $F(W) = \frac{1}{2 n} \sum_{j=1}^{n} \left(\max(0, \inp{w_1}{X_j} \alpha_1  - y_j \right)^2$
	\item Gradient: $\nabla F(W) = \begin{pmatrix} \frac{\partial F}{\partial w_1} \end{pmatrix} =
		\frac{\alpha_1}{n} \sum_{j=1}^{n} e_j s_{1, j} X_j$
	\item Algo: $W^{t+1} = W^t - \nabla F(W^t)$
	\item Initialization: $W^0 = \begin{pmatrix} w_1\end{pmatrix} = \begin{pmatrix} 1 & 0\end{pmatrix} $, $\alpha = \begin{pmatrix} \alpha_1 \end{pmatrix}=\begin{pmatrix} 1 \end{pmatrix} $
\end{itemize}

Run gradient descent:

\begin{itemize}
	\item Iteration 0:
	\begin{itemize}
		\item $W^0 = \begin{pmatrix} 1 & 0\end{pmatrix} $
		\item $s_1 = \begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix} $
		\item $e = \begin{pmatrix} \inp{w_1}{x_1} \alpha_1 - y_1 \\ \inp{w_1}{x_2} \alpha_1 - y_2\\ \inp{w_1}{x_3} \alpha_1 - y_3 \end{pmatrix} =
			\begin{pmatrix}  \inp{\begin{pmatrix} 1 & 0 \end{pmatrix}}{\begin{pmatrix}1 & 1\end{pmatrix}} - 2 \\ \inp{\begin{pmatrix} 1 & 0 \end{pmatrix}}{\begin{pmatrix}2 & 1\end{pmatrix}} - 4\\ \inp{\begin{pmatrix} 1 & 0 \end{pmatrix}}{\begin{pmatrix}4 & 1\end{pmatrix}} - 8\end{pmatrix} =
			\begin{pmatrix}1-2 \\ 2-4 \\ 4-8  \end{pmatrix} = \begin{pmatrix} -1 \\ -2 \\ -4 \end{pmatrix} $
		\item $e_j = \inp{w_1}{X_j} \alpha_1 - y_j =  w_1^1 x_j + w_1^2 - a x_j = x_j (w_1^1 - a) + w_1^2$
		\item $W^1 = \begin{pmatrix} w^1_1 & w^2_1 \end{pmatrix}  - \frac{1}{n} \sum_{j=1}^{3} (x_j(w^1_1 - a) + w_1^2) X_j$
		\item $W^1 = \begin{pmatrix} w^1_1 & w^2_1 \end{pmatrix} - \frac{1}{n}\sum_{j=1}^{3} \begin{pmatrix} x_j^2 (w^1_1 - a) + x_j w^2_1 & x_j(w^1_1 - a) + w^2_1 \end{pmatrix}   $
		\item $W^1 = \begin{pmatrix}w_1^1 -\frac{w_1^2}{n} (x_1 + x_2 + x_3) - \frac{(w_1^1 - a)}{n} (x_1^2 + x_2^2 + x_3^2)  & ok \end{pmatrix} $
		\item $b = \frac{x_1 + x_2 + x_3}{n} = 7/3, c = \frac{x^2_1 + x^2_2 + x^2_3}{n} = 21/3 = 7$ % et beh la somme des carrés.
		\item $W^1 = \begin{pmatrix}w_1^1 -w_1^2 b - (w_1^1 - a) c  &  w^2_1 - (w_1^1 - a) b + w^2_1\end{pmatrix} $
		\item $W^1 = \begin{pmatrix}w_1^1 -w_1^2 b - w_1^1 c  + a c  &  w^2_1 - w_1^1 b + w^2_1 + a b \end{pmatrix} $
		\item $W^1 = \begin{pmatrix} 1 - 0 -7 + 14 & 0 - 7/3 + 0 + 14/3 \end{pmatrix} = \begin{pmatrix} 8 &7/3 \end{pmatrix} $
		\item $W^1 = W^0  + 7 \begin{pmatrix}  1 & \frac{1}{3}\end{pmatrix} $
		\item $X_1 + 2 X_2 + 4 X_3 = \begin{pmatrix} 1+4+16& 1+2+4 \end{pmatrix} = \begin{pmatrix} 21 & 7 \end{pmatrix} = 7 \times 3 \begin{pmatrix} 1 & \frac{1}{3} \end{pmatrix}  $
	\end{itemize}
\end{itemize}

\section{Simple example 2D setting, grid jko}

From one dimensional data, we add a dimension filled with ones to act as a bias for the first layer. The output of one ReLU neuron for one data point $(x, 1) \in \R^2$:

\begin{equation}
	w, b, \alpha \in \R \rightarrow \max(0, w x + b) \alpha
\end{equation}

The loss against labels $y_j \in \R$ using squared loss of the whole network of neurons is the double sum:

\begin{equation}
	 \mathcal{L} = \sum_{j=1}^n \left(\left(\sum_{i=1}^m \max(0, w_i x_j + b_i) \alpha_i \right)  - y_j \right)^2
\end{equation}

The mean-field limit of this network requires taking an infinite-width ReLU network where parameters are described by a measure $\mu$, and its output by an integral:

\begin{equation}
	\int_{\R^2} m((w, b); x) ~ \dd \mu((w, b))
\end{equation}
 
To simplify things, we restrict $\alpha_i$ to $\{-1, 1\}$ and to not be a trainable parameter anymore. We keep the same expressivity(as long as we provide both a positive($\alpha_i=1$) and negative($\alpha_i=-1$) version of the neuron) but this change will slightly alter the training dynamic in some cases. For example , we can match the output of one neuron (of the original network) by simply scaling the first layer by the seconder layer ($\alpha$):

\begin{equation}
	\max(0, w_i x + b_i) \alpha_i = \max\left(0, |\alpha_i|(w_i x + b_i)\right) \ \text{sign}(\alpha_i)
\end{equation}

Our network with restricted $\alpha_i$ would describe this neuron using only two trainable parameters: $(|alpha_i| w_i, |\alpha_i| b_i)$ and fix its sign in the output.

The measure is on the parameter space. In order to do simulations we discretize the parameter space, by taking a uniform grid in $\R^2$ centered on $(0, 0)$: $(w_i, b_i)_{i=1, \dots m}$

We can see that we have the same output and expressivity as the regular ReLU network by taking a measure $\mu = \sum_{i=1}^{m} p_i \dirac_{\param_i = \vw_i}$ with ($\sum_i p_i=1$) and $m((w_i, b_i); x) = \max(0, w_i x + b_i) \alpha_i$, we have this equality:

\begin{equation}
	\int_{\R^2} m((w, b); x) \dd \mu((w, b)) = \sum_{i=1}^{m} \max(0, w_i x_j + b_i) \alpha_i p_i
\end{equation}

In this case, the first layer is fixed: the change of direction($\frac{-b_i}{w_i}$) and slope $(w_i)$ of a neuron is described by a mass displacement from point A to point B. 

The movemement is described by a PDE and simulated on a grid. Each point $i$ of the grid has a weight $p_i \in \R$, and as a whole $p \in \R^m$ is the discretized distribution.

The same wasserstein gradient flow can be computed by this step:

\begin{equation}
	\mu(t+1) = \argmin_{\mu \in \mathcal{M}(\paramS)} F(\mu) + \frac{1}{2 \step} W_2(\mu; \mu(t))
\end{equation}

We tried different ways of computing the Wasserstein Gradient Flow. 

\begin{itemize}
	\item JKO stepping: entropic approximation on a fixed grid. Pros: not very dependant on dimension $d$. Cons: add another loop and more parameters to fine tune, introduce diffusion.
		\item Sliced Wasserstein: Pros: midly dependant on $d$ without diffusion. Differentiable with pytorch. Cons: Parameters to tune, distance to true WS distance has to be studied
		\item Direct EMD distance from POT library. Pros: differentiable with pytorch. Cons: Might be slow with $d$
\end{itemize}

Preliminary results using the EMD distance indicate no particular differences between the gradient flow and the wasserstein gradient flow.

\subsection{JKO stepping with Dykstra's algorithm}

\begin{align}
p_{t+1} := & \prox^{W_{\gamma}}_{\tau f}(p_t) \\
							= & \argmin_{p \in \text{simplex}} W_{\gamma}(p, q) + \tau f(p) \\
							= &\argmin_{p \in \text{simplex}}  \left( \min_{\pi \in \Pi(p, q)} \inp{c}{\pi} + \gamma E(\pi) \right) + \tau f(p)
\end{align}

Where $\pi$ is a mapping, $c$ the ground cost for every point on the grid. When the ground cost between two points in the euclidian space is $c_{i,j} = \norm{x_i- x_j}^2$, (and $\gamma=0$, $f$ smooth...), this scheme formaly discretize the above mentionned PDE.

To do the step above, we'll use a bregman splitting approach that replace the single implicit $W_\gamma$ proximal step by many iterative KL implicit proximal steps. Specifically(?) Dykstra's algorithm for JKO stepping. This involve using the gibbs kernel:$\xi = e^{-\frac{c}{\gamma}} \in \mathbb{R}^{N \times N}_{+, \ast}$


\begin{algorithm}
\caption{JKOstep}
\begin{algorithmic}[1]
\State $p \gets p_0 \in \R^m$
\State $q_{\text{norm}} \gets \lVert p \rVert^2$
\State $a, b \gets \mathbf{1}, \mathbf{1} \in \R^m$ \Comment{Initialize vectors with ones}
\For{$i \gets 1$ \textbf{to} $T$}
\State $p \gets \text{prox}^{\text{KL}}_{\tau/\gamma}(\xi b)$
    \State $a \gets p / (\xi b)$
    \State $\text{ConstrEven} \gets \frac{\lVert b \cdot (\xi a) - q \rVert}{q_{\text{norm}}}$
    \State $b \gets q / (\xi a)$
    \State $\text{ConstrOdd} \gets \frac{\lVert a \cdot (\xi b) - p \rVert}{q_{\text{norm}}}$
    
    \If{$\text{ConstrOdd} < \text{tol}$ \textbf{and} $\text{ConstrEven} < \text{tol}$}
        \State \textbf{break}
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

%\includegraphics[width=0.7\textwidth]{bigscale_start}
\section{Classic setup}

Data $x_j \in \R^d$ and labels $y_j \in \R$, $j=1,..,n$

First layer $w_i \in \R^d$, second layer $\alpha_i \in \R$, $i=1,..,m$

$\step>0$ step-size, $\reg$ regularization

\begin{equation}
	 \mathcal{L}(W, \alpha) = \sum_{j=1}^n \bigg( \underbrace{\sum_{i=1}^m \max(0, w_i^\top x_j) \alpha_i}_{\text{Network's Output}} - y_j \bigg)^2 + \underbrace{\lambda \sum_{i=1}^m \| w_i \|^2_2 + \alpha_i^2}_{\text{Weight Decay}}
\end{equation}


\textbf{Discret time.}

Full-batch gradient descent

\begin{equation}
	(W, \alpha)_{t+1} = (W, \alpha)_t - \step \nabla \mathcal{L}((W, \alpha)_t)
\end{equation}

Implicit

\begin{equation}
	\param_{t+1} = \argmin_{\param} \mathcal{L}(\param) +\frac{1}{2\step} \norm{\param - \param_t}
\end{equation}

\textbf{Continuous time.}

Taking $\step \to 0$, we get the gradient flow: $\frac{\dd \param_t}{\dd t} = - \nabla \mathcal{L}(\param_t)$. We make ReLU differentiable with $\sigma'(0)=0$ as justified in \citep{boursierGradientFlowDynamics2022}.

\section{Infinite width, using a measure: mean-field}

\textbf{Mean-field limit}\citep{chizatGlobalConvergenceGradient2018}: For a sufficiently large width, the training dynamics of a NN can be coupled with the evolution of a probability distribution described by a PDE.

If [...] converges, with $m \rightarrow \infty$ (many-particle limit), our particles of interest converges to a Wasserstein gradient flow of F:

\begin{equation}
	\partial \mu_t = - \diver(v_t \mu_t) \text{ where } v_t \in - \partial F'(\mu_t)
\end{equation}

\begin{equation}
	\int_\paramS m(\param; x) \dd \mu(\param) = \frac{1}{m} \sum_{i=1}^{m} \inp{\vw_i}{\vx_j}_+ \alpha_i
\end{equation}

Different ways to use a measure to represent the neurons of a two layer network:

\begin{itemize}
	\item $\paramS = \R^d \times \R$, measure $\mu = \frac{1}{m} \sum_{i=1}^{m} \dirac_{\param_i = (\vw_i, \alpha_i)}$, output of one neuron $m(\param=(\vw,\alpha); \vx) = \inp{\vx}{\vw}_+ \alpha$: (works, output matches discrete)
	\item $\paramS = \R^d$, measure $\mu = \frac{1}{m} \sum_{i=1}^{m} \alpha_i \dirac_{\param_i = \vw_i}$ output of one neuron $m(\param=\vw; \vx) = \inp{\vx}{\vw}_+$ (works)
	\item $\paramS = \R^d \times \R^d$, output of one neuron $m(\tilde{\vw}_+, \tilde{\vw}_-, \vx) = \inp{\tilde{\vw}_+}{\vx} - \inp{\tilde{\vw}_-}{\vx}$ (works, separate neg and positive)
	\item $\paramS = (S^{d-1} \times \R)$, output of one neuron $m((\vd, \tilde{\alpha}); \vx) = \tilde{\alpha} \inp{\vd}{\vx} = \tilde{\alpha}\  \mathds{1}_{\inp{\vd}{\vx}>0} $ (works), mapping: $\vd = \frac{\vw}{\norm{\vw}}$ and $\tilde{\alpha}=\norm{\vw} \alpha$. Gradient are not equal to discrete.
\end{itemize}

\subsection{Algorithm, discretize the measure's space}

Take a grid of $N$ points in $\paramS$, we can match the notation above by taking a neuron for each point of the grid $m=N$.

\begin{equation}
	\mu(t+1) = \argmin_{\mu \in \mathcal{M}(\paramS)} F(\mu) + \frac{1}{2 \step} W_2(\mu; \mu(t))
\end{equation}

% A essayer: KL à la place de distance wasserstein.

% Remark: le 1/m c'est principalement pour être ok à l'infini. Dans le papier JKO \citep{carlierConvergenceEntropicSchemes2017} ils utilisent un vecteur de proba

% Take $\step \to 0$, get gradient flow. Take $m \to \infty$, get wasserstein gradient flow \citep{bachGradientDescentInfinitely2021}, and if it converges, it goes to the global optimal.

\subsection{JKO}

What we compute by using the entropic JKO flow iterations.

\begin{align}
	\forall t > 0, p_{t+1} := & \prox^{W_{\gamma}}_{\tau f}(p_t) \\
							= & \argmin_{p \in \text{simplex}} W_{\gamma}(p, q) + \tau f(p) \\
							= &\argmin_{p \in \text{simplex}}  \left( \min_{\pi \in \Pi(p, q)} \inp{c}{\pi} + \gamma E(\pi) \right) + \tau f(p)
\end{align}

% $f$ "should" be convex and with a closed form proximal % from JKO paper.

\begin{itemize}
	\item \href{https://arxiv.org/pdf/2206.05262.pdf}{Meta Optimal Transport (paper)} and \href{https://github.com/facebookresearch/meta-ot}{(code git)}: InputConvexNN to predict solution of OT problem
	\item \href{https://arxiv.org/pdf/2106.06345.pdf}{JKOnet (paper)} and \href{https://github.com/bunnech/jkonet}{(code git)}:
		\begin{itemize}
			\item \href{https://github.com/bunnech/jkonet/tree/main/jkonet/models}{/models} \verb|->| sinkhorn loss defined in loss.py, differentiable loop in fixed point.py
			\item next step: trying to create the right \href{https://ott-jax.readthedocs.io/en/latest/_autosummary/ott.geometry.geometry.Geometry.html#ott.geometry.geometry.Geometry}{Geometry} object from OTT library, which is what's used for sinkhorn
		\end{itemize}
\end{itemize}

\subsection{Papers}

\href{https://arxiv.org/pdf/1502.06216.pdf}{The algo we try to implement}

Paper with a \href{https://arxiv.org/pdf/1512.02783.pdf}{specific case that doesn't match ours:} 

In the future, \href{https://arxiv.org/pdf/2106.00736.pdf}{large-scale waserstein gradient flows}

\subsubsection{Grid problems}

The grid currently dictate the neuron's scale, giving multiple choices. One solution: duplicate each neuron, make one with a small scale and one with a very big scale.
